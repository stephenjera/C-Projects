#include <iostream>
#include <fstream>

class HandyFunctions {
public:
	// If we list all the natural numbers below 10 that are multiples of 3 or 5,
	// we get 3, 5, 6 and 9. The sum of these multiples is 23. 
	// Find the sum of all the multiples of 3 or 5 below 1000.
	/*
	* Finds the sum of all the multiples of a or b below c.
	* @param multiple1: the first multiple 
	* @param multiple2: the second multiple
	* @param limit: the highest number to 
	* @return total: the sum of all multiples of both numbers 
	*/
	int sumOfMultiples(int multiple1, int multiple2, int limit) {
		int remainder = 0;
		int total = 0;
		// start at 1 because don't care about 0 
		for (int i = 1; i < limit; i++) {
			remainder = i % multiple1;
			if (remainder != 0) {
				remainder = i % multiple2;
				if (remainder == 0) {
					total += i;
					//std::cout << "Value: " << total << "\n";
				}
			}
			else {
				total += i;
				//std::cout << "Value: " << total << "\n";
			}
		}
		return total;
	}
	// Each new term in the Fibonacci sequence is generated by adding the previous two terms.
	// By starting with 1 and 2, the first 10 terms will be : 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ... 
	// By considering the terms in the Fibonacci sequence whose values do not exceed four million,
	// find the sum of the even - valued terms.
	/*
	* Find the sum of even fibonacci numbers
	* @param value1: first number
	* @param value2: second number
	* @param limitFib: counting limit of numbers included
	*/
	int fibonacciEvenSum(int value1, int value2, int limitFib) {
		int remainder = 0;
		int fibonacci = 0;
		int total = 0;

		fibonacci = value1 + value2;

		for (int i = 0; i < limitFib; i++) {
			remainder = value1 % 2;
			if (remainder != 0) {
				remainder = value2 % 2;
				if (remainder == 0) {
					total = value1 + value2;
					//std::cout << "Value: " << total << "\n";
				}
			}
		}

	}

	// A palindromic number reads the same both ways.
	// The largest palindrome made from the product of two 2 - digit numbers is 9009 = 91 × 99. 
	// Find the largest palindrome made from the product of two 3 - digit numbers.
	/*
	* Find the largest palindrome made from the product of two numbers
	* @param a: first number
	* @param b: second number
	* @return palindrome: largest palindrome
	*/
	int findPalindrome(int a, int b) {
		int palindrome;
		//int a = 99, b = 99;
		while (1) {
			if (a * b == reverseNumber(a, b)) {
				break;
			}
			if (a == b) {
				a--;
			}
			else if (a < b) {
				b--;
			}
			else if (a > b) {
				a--;
			}		
		}
		palindrome = a * b;
		return palindrome;
	}

	/*
	* Reverses number 
	* @param a: first number
	* @param b: second number
	* @return reversedNumber: reversed number
	*/
	int reverseNumber(int a, int b) {
		int remainder = 0;
		int reversedNumber = 0;
		int n = a * b;
		while (n != 0)
		{
			remainder = n % 10;
			reversedNumber = reversedNumber * 10 + remainder;
			n /= 10;
		}
		return reversedNumber;
	}

	// 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 
	// without any remainder. What is the smallest positive number that is evenly divisible 
	// by all of the numbers from 1 to 20 ?
	/*
	* Finds smallest number divisible within a range (currently off by 1)
	* @param start: number to start counting from
	* @param end: highest factor required from number
	* @return result: smallest number divisible within a range
	*/
	int divideMany(int start, int end) {
		int remainder = 0; 
		int divisor = 3; 
		int result = 0;
		while (divisor != end) {
			while (1) {
				remainder = start % divisor;
				if (remainder == 0) {
					if (divisor == end) {
						break;
					}
					divisor++;
					std::cout << "divisor: " << divisor << "\n";
				}
				else {
					divisor = 3; // Reset divisor
					break;
				}	
			}
			/*if (divisor == end) {
				break;
			}*/
			start++;
			std::cout << "start: " << start << "\n";
		}
		result = start - 1; // Find more elegant solution
		return result;
		/* Attempt 1*/
		/*int counter = 1;
		int tempVal = 0;
		int i;
		while (1) {
			for (i = start; i <= end; i++) {
				tempVal %= i;
				if (tempVal != 0) {
					break;
				}
			}
			std::cout << "i: " << i << "\n";
			std::cout << "counter:" << counter << "\n";
			if (i == end) {
				break;
			}
			else {
				counter++;
				tempVal = counter;
			}
			
		}	
		return counter;*/
	}

	// By listing the first six prime numbers : 2, 3, 5, 7, 11, and 13, 
	// we can see that the 6th prime is 13. What is the 10,001st prime number ?
	/*
	* Finds the prime number at position entered (currently doesn't work correctly)
	* @param desiredPrime: position of prime
	* @return primeNumber: prime number at entered position
	*/
	int primeFinder(int desiredPrime) {
		int testPrime = 2;
		int temp = 0; // is number prime
		int primeNumber = 0;
		int counter = 0;
		while (counter != desiredPrime) {
			int temp = primeCheck(testPrime);
			if (temp == 1) {
				counter++;
				primeNumber = testPrime;
			}
			testPrime++;	
		}
		return primeNumber;
	}
	/*	 Attempt 1
	int primeFinder(int desiredPrime) {
		int i = 1; // loop counter 
		int primeNumber = 2; // 0 and 1 are not prime 
		int primeCheck = 2;
		int divisor = 1;

	
		while (i != desiredPrime) {
			primeCheck %= divisor;
			std::cout << "primeCheck: " << primeCheck << "\n";
			if (primeCheck == 0) {
				if (divisor == primeCheck) {
					primeNumber = primeCheck;
					i++;
					std::cout << "i: " << i << "\n";
				}
			}
			primeCheck++;
			divisor++;
			//std::cout << divisor;
		}
		return primeNumber;*/


		/*for (i = 3; i < a; i++) {
			i %= 2;
			if (i != 0) {

			}
		}
	}*/

	/*
	* Checks if a number is prime
	* @param number: number to test
	* @return: returns 1 if prime and 0 if not prime
	*/
	int primeCheck(int number){
		int numCheck = 0;
		for (int i = 2; i <= number; i++) {
			numCheck = number % i;
			if (numCheck == 0 and number != i) {
				return false;
				break;
			}
			else {
				return true;
			}
		}
	}

	// Starting in the top left corner of a 2×2 grid, 
	// and only being able to move to the right and down, 
	// there are exactly 6 routes to the bottom right corner.
	// How many such routes are there through a 20×20 grid?
	/*
	* Find route through a grid
	*/
	int findRoutes() {
		int grid[3][3]; // grid size = desired + 1
		int right = 0;
		int down = 0;
		// Mark array with specfied number 
		for (int i = 0; i < 3; i++) {
			grid[2][i] = 1; // Bottom of array
			grid[i][3] = 2; // Right side of array 
		}

		while (1) {

		}

	}


	// By starting at the top of the triangle belowand moving to adjacent 
	// numbers on the row below, the maximum total from top to bottom is 23.
	// Find the maximum total from top to bottom in triangle.txt (attached to the email),
	// a 15K text file containing a triangle with one-hundred rows.
	int findTriTotal() {

		char data[100];
		// open a file in read mode.
		std::ifstream infile;
		infile.open("triangle.txt");

		std::cout << "Reading from the file" << "\n";
		infile >> data;

		// write the data at the screen.
		std::cout << data << "\n";
		
	}
};

int main() {
	int sum = 0;
	HandyFunctions testObj;

	sum = testObj.sumOfMultiples(3,5,6);
	std::cout << sum << "\n";

	/*int reversedNumber = testObj.reverseNumber(1,5);
	std::cout << reversedNumber << "\n";*/

	/*int palindrome = testObj.findPalindrome(99,99);
	std::cout << palindrome << "\n";*/
	
	/*int divideTest = testObj.divideMany(1, 5);
	std::cout << divideTest << "\n";*/

	/*testObj.primeFinder(4);
	int primeTest = testObj.primeFinder(10);
	std::cout << "primeTest: " << primeTest << "\n";

	std::cout <<  "Is prime: " << testObj.primeCheck(2);*/
	
	return 0;
}